# design-pattern

### 디자인 패턴 
개발하면서 발생하는 반복적인 문제들을 어떻게 해결할 것인지에 대한 해결 방안으로 

실무에서 비즈니스 요구 사항을 프로그래밍으로 처리하면서 만들어진 다양한 해결책 중에서 많은 사람들이 인정한 모범 사례이다.

이러한 디자인 패턴은 객체 지향 4대 특성 (캡슐화, 추상화, 상속, 다형성)과 설계 원칙 (SOLID)을 기반으로 구현되어있다.

### 디자인 패턴의 장점
1. 재사용성 : 반복적인 문제에 대한 일반적인 해결책을 제공하므로, 이를 재사용하여 유사한 상황에서 코드를 더 쉽게 작성할 수 있다.
2. 가독성 : 일정한 구조로 정리하고 명확하게 작성하여 개발자가 코드를 이해하고 유지보하기 쉽게 만든다.
3. 유지보수성 : 코드를 쉽게 모듈화 할 수 있으며, 변경이 필요한 경우 해당 모듈만 수정하여 유지보수가 쉬워진다.
4. 확장성 : 새로운 기능을 추가하거나 변경할 때 디자인 패턴을 활용하여 기존 코드를 변경하지 않고도 새로운 기능을 통합할 수 있다.
5. 안정성과 신뢰성 : 수많은 사람들이 인정한 모범 사례로 검증된 솔루션을 제공한다.

### 디자인 패턴의 종류 

1. 생성 패턴
    - Singleton (싱글톤 패턴) : 하나의 클래스 인스턴스를 전역에서 접근 가능하게 하면서 해당 인스턴스가 한번만 생성되도록 보장하는 패턴이다.
    - Factory Method (팩토리 메서드 패턴) : 객체를 생성하기 위한 인터페이를 정의하고, 서브 클래스에서 어떤 클래스의 인스턴스를 생성할지 결정하는 패턴이다.
    - Abstract Factory (추상 팩토리 패턴) : 관련된 객체들의 집합을 생성하는 인터페이스를 제공하며, 구체적인 팩토리 클래스를 통해 객체 생성으르 추상화하는 패턴이다.
    - Builder (빌더 패턴) : 복잡한 객체의 생성 과정을 단순화하고, 객체를 단계적으로 생성하여 구성하는 패턴이다.
    - Prototype (프로토타입 패턴) : 객체를 복제하여 새로운 객체를 생성하는 패턴으로, 기존 객체를 템플릿으로 사용하는 패턴이다.

   
2. 구조 패턴
    - Adapter (어댑터 패턴) : 인터페이스 호환성을 제공하지 않는 클래스를 사용하기 위해 래퍼(Wrapper)를 제공하는 패턴이다.
    - Bridge (브릿지 패턴) : 추상화와 구현을 분리하여 두가지를 독립적으로 확장할 수 있는 패턴이다.
    - Composite (컴포지트 패턴) : 개별 객체와 복합 객체를 동일하게 다루어 트리 구조의 객체를 구성하는 패턴이다.
    - Decorator (데코레이터 패턴) : 객체에 동적으로 새로운 기능을 추가하여 객체를 확장할 수 있는 패턴이다.
    - Facade (퍼사드 패턴) : 서브시스템을 더 쉽게 사용할 수 있도록 단순한 인터페이스를 제공하는 패턴이다.
    - Proxy (프록시 패턴) : 다른 객체에 대한 대리자(Proxy)르르 제공하여 접근 제어, 지연 로딩등을 구현하는 패턴이다.

3. 행위 퍁턴
    - Observer (옵저버 패턴) : 객체 간의 일대다 종속 관계를 정의하여 한 객체의 상태 변경이 다른 객체들에게 알려지도록 한다.
    - Strategy (전략 패턴) : 알고리즘을 정의하고, 실행 중에 선택할 수 있게 한다.
    - Command (커맨드 패턴) : 요청을 객체로 캡슐화하여 요청을 매개변수화 하고, 요청을 큐에 저장하거나 로깅하고 실행을 지연시킨다.
    - State (상태 패턴) : 객체의 상태를 캡슐화하고, 상태 전환을 관리한다.
    - Visitor (방문자 패턴) : 객체 구조를 순회하면서 다양한 연산을 수행할 수 있게 한다.
    - Interpreter (인터프리터 패턴) : 언어나 문법에 대한 해석기를 제공하여 주어진 언어로 표현된 문제를 해결하는 패턴이다.
    - Iterator (이터레이터 패턴) : 컬렉션 내의 요소들에 접근하는 방법을 표준화하여 컬렉션의 내부 구조에 독립적으로 접근할 수 있는 패턴이다.